# -*- coding: utf-8 -*-
"""jobrecrutment. ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ynhPp0yMcTtptNPOM9CnHk3AxlM5XMA2
"""

import numpy as np
import pandas as pd

# Set number of samples
num_samples = 2000

# Generate synthetic dataset
data = {
    "CGPA": np.round(np.random.uniform(6.0, 10.0, num_samples), 2),  # CGPA between 2.0 and 4.0
    "Degree_Level": np.random.choice(["Bachelors", "Masters"], num_samples),
    "Years_of_Experience": np.random.randint(0, 10, num_samples),  # Experience between 0 and 10 years
    "Programming_Languages": np.random.choice(
        ["Python,Java,C++", "JavaScript,C++,Java"], num_samples
    ),
    "Technical_Skills": np.random.choice(
        ["Machine Learning/Datascience", "Web Development"],
        num_samples
    ),

    "Job_Placement": np.random.choice(["Yes", "No"], num_samples, p=[0.6, 0.4]),
    "Gender": np.random.choice(["M", "F"], num_samples)
}

# Create DataFrame
Employee_dataset = pd.DataFrame(data)

# Define mapping dictionaries
technical_skills_mapping = {'Web Development': 0, 'Machine Learning/Datascience': 1}

job_placement_mapping = {'Yes': 1, 'No': 0}
gender_mapping = {'M': 1, 'F': 0}
programming_languages_mapping = {'Python,Java,C++': 0, 'JavaScript,C++,Java': 1}
degree_level_mapping = {'Bachelors': 0, 'Masters': 1}

# Apply mappings to transform categorical data
Employee_dataset['Technical_Skills'] = Employee_dataset.Technical_Skills.map(technical_skills_mapping)

Employee_dataset['Job_Placement'] = Employee_dataset.Job_Placement.map(job_placement_mapping)
Employee_dataset['Gender'] = Employee_dataset.Gender.map(gender_mapping)
Employee_dataset["Programming_Languages"] = Employee_dataset.Programming_Languages.map(programming_languages_mapping)
Employee_dataset['Degree_Level'] = Employee_dataset.Degree_Level.map(degree_level_mapping)



# Save to CSV
Employee_dataset.to_csv("Employee_dataset.csv", index=True)

original_data=pd.read_csv("Employee_dataset.csv")
original_data.drop('Unnamed: 0',axis=1,inplace=True)

original_data['Job_Placement'].value_counts()

from sklearn.utils import resample
data_minority=original_data[original_data['Job_Placement']==0]
data_majority=original_data[original_data['Job_Placement']==1]
data_minority_upsampled=resample(data_minority,replace=True,n_samples=len(data_majority),random_state=123)
data_balanced=pd.concat([data_minority_upsampled,data_majority] )
data_balanced['Job_Placement'].value_counts()
data_balanced['Technical_Skills'].value_counts()

x=data_balanced.copy().drop('Job_Placement',axis=1)
y=data_balanced.copy()['Job_Placement']
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.3)
x_train.shape,y_train.shape,x_test.shape,y_test.shape

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler()
x_train=scaler.fit_transform(x_train)
x_test=scaler.transform(x_test)
x_train

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

knn=KNeighborsClassifier(n_neighbors=5)
knn.fit(x_train,y_train)
knn_y_pred=knn.predict(x_test)
accuracy_score=accuracy_score(knn_y_pred,y_test)
accuracy_score

from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

conf_mat=confusion_matrix(y_test,knn_y_pred)
fig=plt.figure(figsize=(10,10))



group_names=['True Neg','False Pos','False Neg','True Pos']
group_counts=["{0:0.0f}".format(value) for value in conf_mat.flatten()]
labels=[f"{v1}\n{v2}" for v1,v2 in zip(group_names,group_counts)]
labels=np.asarray(labels).reshape(2,2)

sns.heatmap(conf_mat,annot=labels,annot_kws={"size":16},fmt='',cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

from sklearn.tree import DecisionTreeClassifier
dt=DecisionTreeClassifier()
dt.fit(x_train,y_train)
dt_y_pred=dt.predict(x_test)
dt_accuracy=dt.score(x_test,y_test)
dt_accuracy

conf_mat=confusion_matrix(y_test,dt_y_pred)
fig=plt.figure(figsize=(10,10))
group_names=['True Neg','False Pos','False Neg','True Pos']
group_counts=["{0:0.0f}".format(value) for value in conf_mat.flatten()]
labels=[f"{v1}\n{v2}" for v1,v2 in zip(group_names,group_counts)]
labels=np.asarray(labels).reshape(2,2)

sns.heatmap(conf_mat,annot=labels,annot_kws={"size":16},fmt='',cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

from sklearn.linear_model import LogisticRegression
lr=LogisticRegression()
lr.fit(x_train,y_train)
lr_y_pred=lr.predict(x_test)
lr_accuracy=lr.score(x_test,y_test)
lr_accuracy

from sklearn.ensemble import RandomForestClassifier
random_forest=RandomForestClassifier()
# Fit the model to the training data before making predictions
random_forest.fit(x_train, y_train) # This line is added to train the model
random_forest.predict(x_train[10].reshape(1,-1))

print("predicted class: ",random_forest.predict(x_train[10].reshape(1,-1))[0])
print("actual class: ",y_test.iloc[10])

original_data=pd.read_csv("Employee_dataset.csv")
original_data.drop('Unnamed: 0',axis=1,inplace=True)

def prediction(CGPA,Degree_Level,Years_of_Experience,Programming_Languages,Technical_Skills,Gender):
    data=pd.DataFrame({
        'CGPA':[CGPA],
        'Degree_Level':[Degree_Level],
        'Years_of_Experience':[Years_of_Experience],
        'Programming_Languages':[Programming_Languages],
        'Technical_Skills':[Technical_Skills],

        'Gender':[Gender]
    } )
    data=pd.DataFrame(data)
    data['Degree_Level']=data.Degree_Level.map({'Bachelors':0,'Masters':1})
    data['Programming_Languages']=data.Programming_Languages.map({'Python,Java,C++':0,'JavaScript,C++,Java':1})
    data['Technical_Skills']=data.Technical_Skills.map({'Machine Learning/Datascience':0,'Web Development':1})

    data['Gender']=data.Gender.map({'M':1,'F':0})
    scaled_df=scaler.transform(data)
    result=random_forest.predict(scaled_df).reshape(1,-1)
    return result[0]

CGPA=5.0
Degree_Level='Masters'
Years_of_Experience=1
Programming_Languages='JavaScript,C++,Java'
Technical_Skills='Web Development'
Gender='F'

result=prediction(CGPA,Degree_Level,Years_of_Experience,Programming_Languages,Technical_Skills,Gender)
result[0]
if result[0]==1:
    print("Candidate will be placed")
else:
    print("Candidate will not be placed")

import pickle
pickle.dump(random_forest,open('model.pkl','wb'))
pickle.dump(scaler,open('scaler.pkl','wb'))

def placement():
    if request.method == 'POST':
        CGPA= request.form['CGPA']
        Degree_Level = request.form['Degree_Level']
        Years_of_Experience = request.form['Years_of_Experience']
        Programming_Languages = request.form['Programming_Languages']
        Technical_Skills = request.form['Technical_Skills']
        Gender = request.form['Gender']
        result = prediction(CGPA, Degree_Level, Years_of_Experience, Programming_Languages, Technical_Skills, Gender)

        if result == 1:
            pred = "Placed"
            rec = "We recommend you that this is the best candidate for you business"
            return render_template('job.html', result=pred, rec=rec)

        else:
            pred = "Not Placed"
            rec = "We recommend you that this is not the best candidate for your business"
            return render_template('job.html', result=pred,rec=rec)

    return redirect(url_for('index'))